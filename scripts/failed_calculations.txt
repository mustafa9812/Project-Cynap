# IR-COOLING RATE -------------------------------------------------------------------------------------------------------------------------------------------------------------------
# WAVENUMBER & INTENSITY DATA
df = pd.read_csv('/Users/Mustafa/Documents/GitHub/Project-Cynap/Cynapfolder/Database/neutral1cyano_transitions.tbl', 
                 skiprows=11, 
                 sep='\s+', 
                 names=["UID", "FREQUENCY", "INTENSITY", "SCALE", "SYMMETRY"])

wavenumber_list = df["FREQUENCY"].tolist()
intensity_list = df["INTENSITY"].tolist()

# CONSTANTS & PARAMETERS
max_photon_frequency = 2.0e15 
min_photon_frequency = 5.0e14 

# LISTS
energies_list = []
A_list = []
k_IR_list = []
T_eff_list = []
frequency_list = np.logspace(np.log10(min_photon_frequency),np.log10(max_photon_frequency),num=51)

# FUNCTIONS
def PAH_effective_temperature(light_freq, Nc, bond_energy):
    T_eff = 2000 * ((h_eV * light_freq) / Nc) ** 0.4 * (1 - 0.2 * bond_energy / (h_eV * light_freq)) # energies in eV
    return T_eff

def einstein_coefficient(wavenumber, intensity):
    A = (1.2512 * 10**(-7)) * (wavenumber ** 2) * intensity
    return A

def IR_cooling_rate(A, T_eff, wavenumber):
    freq_hz = wavenumber * c_cm
    return A / (np.exp((h * freq_hz) / (k_B * T_eff) - 1))

# CALCULATIONS
for i in frequency_list:
    T_eff = PAH_effective_temperature(i, Nc, N_bond_energy) 
    T_eff_list.append(T_eff) 
    energies_list.append(h_eV * i)

for wavenumber, intensity, temperature in zip(wavenumber_list, intensity_list, T_eff_list):
    A = einstein_coefficient(wavenumber, intensity)
    k_IR = IR_cooling_rate(A, T_eff=temperature, wavenumber=wavenumber)

    A_list.append(A)
    k_IR_list.append(k_IR)

# PLOTTING
plt.plot(energies_list, k_IR_list, label='IR Cooling Rate', color='purple')
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# MONTE CARLO SIMULATION FOR CATION 1-CYANONAPHTHALENE

# FUNCTION FOR FUV ABSORPTION CROSS SECTION
def FUV_absorption_cross_section(Nc):
    sigma = 7 * 10**(-18) * Nc
    return sigma

# PARAMETERS FOR MONTE CARLO SIMULATION
num_molecules = 1000
E_min = 0  # eV, lower limit
E_max = 26   # eV, upper limit
Nc = 11
FUV_flux = 1e8 #(photons/cm^2/s)
sigma_FUV = FUV_absorption_cross_section(Nc)  # cm^2
dt = 1e-9     # seconds per timestep
total_time = 0.001  # seconds
timesteps = int(total_time / dt)

# Interpolators (your data must be preloaded)
interp_RRKM = interp1d(C_RRKM_filtered_energies_list_eV, C_k_RRKM_list, bounds_error=False, fill_value=0)
interp_IR = interp1d(C_IR_energies_list_eV, C_k_IR_total, bounds_error=False, fill_value=0)
interp_RF = interp1d(RF_filtered_energies_list_eV, k_RF_list, bounds_error=False, fill_value=0)

# INIT
molecule_energies = np.random.uniform(E_min, E_max, num_molecules)
molecule_alive = np.ones(num_molecules, dtype=bool)
survival_history = []
time_history = []

# LOOP
for t in range(timesteps):
    for i in range(num_molecules):
        if not molecule_alive[i]:
            continue
        E = molecule_energies[i]
        # Rates
        k_RRKM = float(interp_RRKM(E))
        k_IR = float(interp_IR(E))
        k_RF = float(interp_RF(E))
        # Probabilities
        p_FUV = FUV_flux * sigma_FUV * dt
        p_RRKM = k_RRKM * dt
        p_IR = k_IR * dt
        p_RF = k_RF * dt
        # Normalize if total probability > 1
        p_sum = p_RRKM + p_IR + p_RF + p_FUV
        if p_sum > 1:
            p_RRKM /= p_sum
            p_IR /= p_sum
            p_RF /= p_sum
            p_FUV /= p_sum
        rand = np.random.rand()
        if rand < p_RRKM:
            molecule_alive[i] = False
        elif rand < p_RRKM + p_IR:
            molecule_energies[i] = max(E_min, E - 0.05)
        elif rand < p_RRKM + p_IR + p_RF:
            molecule_energies[i] = max(E_min, E - 0.1)
        elif rand < p_RRKM + p_IR + p_RF + p_FUV:
            molecule_energies[i] = min(E_max, E + 0.5)
    # Tracking
    survival_history.append(np.sum(molecule_alive))
    time_history.append(t * dt)
    if t % 100000 == 0:
        print(f"Time {t*dt:.5f}s, Alive: {np.sum(molecule_alive)}")

# PLOT
plt.plot(time_history, survival_history)
plt.xlabel('Time (s)')
plt.ylabel('Surviving Molecules')
plt.title('Monte Carlo Survivability: 1-Cyanonaphthalene Cation')
plt.grid(True)
plt.show()
